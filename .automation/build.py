# !/usr/bin/env python3
"""
Automatically generate source code
"""
import logging
import os
import re
import sys

import superlinter

DOCS_URL_ROOT = "https://github.com/nvuillam/super-linter/tree/POC_RefactorInPython/docs"
DOCS_URL_DESCRIPTORS_ROOT = DOCS_URL_ROOT + "/descriptors"
REPO_HOME = os.path.dirname(os.path.abspath(__file__)) + os.path.sep + '..'


# Automatically generate Dockerfile parts
def generate_dockerfile():
    linters = superlinter.utils.list_all_linters()
    # Gather all dockerfile commands
    docker_from = []
    docker_arg = []
    docker_other = []
    apk_packages = []
    npm_packages = []
    pip_packages = []
    gem_packages = []
    for linter in linters:
        if hasattr(linter, 'install'):
            # Collect Dockerfile items
            if 'dockerfile' in linter.install:
                docker_other += [
                    f"# {linter.linter_name} installation"
                ]
                for dockerfile_item in linter.install['dockerfile']:
                    if dockerfile_item.startswith('FROM'):
                        docker_from += [dockerfile_item]
                    elif dockerfile_item.startswith('ARG'):
                        docker_arg += [dockerfile_item]
                    else:
                        docker_other += [dockerfile_item]
                docker_other += [""]
            # Collect python packages
            if 'apk' in linter.install:
                apk_packages += linter.install['apk']
            # Collect npm packages
            if 'npm' in linter.install:
                npm_packages += linter.install['npm']
            # Collect python packages
            if 'pip' in linter.install:
                pip_packages += linter.install['pip']
            # Collect ruby packages
            if 'gem' in linter.install:
                gem_packages += linter.install['gem']
    # Replace between tags in Dockerfile
    # Commands
    replace_in_file(f"{REPO_HOME}/Dockerfile", "#FROM__START", "#FROM__END", "\n".join(docker_from))
    replace_in_file(f"{REPO_HOME}/Dockerfile", "#ARG__START", "#ARG__END", "\n".join(docker_arg))
    replace_in_file(f"{REPO_HOME}/Dockerfile", "#OTHER__START", "#OTHER__END", "\n".join(docker_other))
    # apk packages
    apk_install_command = 'RUN apk add --update --no-cache \\\n                ' + \
                          " \\\n                ".join(apk_packages)
    replace_in_file(f"{REPO_HOME}/Dockerfile", "#APK__START", "#APK__END", apk_install_command)
    # NPM packages
    npm_install_command = 'RUN npm install --no-cache \\\n                ' + \
                          " \\\n                ".join(npm_packages)
    replace_in_file(f"{REPO_HOME}/Dockerfile", "#NPM__START", "#NPM__END", npm_install_command)
    # Python pip packages
    pip_install_command = 'RUN pip3 install \\\n          ' + \
                          " \\\n          ".join(pip_packages)
    replace_in_file(f"{REPO_HOME}/Dockerfile", "#PIP__START", "#PIP__END", pip_install_command)
    # Ruby gem packages
    gem_install_command = 'RUN gem install \\\n          ' + \
                          " \\\n          ".join(gem_packages)
    replace_in_file(f"{REPO_HOME}/Dockerfile", "#GEM__START", "#GEM__END", gem_install_command)


# Automatically generate a test class for each linter class
# This could be done dynamically at runtime, but having a physical class is easier for developers in IDEs
def generate_linter_test_classes():
    linters = superlinter.utils.list_all_linters()
    superlinter.utils.list_all_linters()
    for linter in linters:
        lang_lower = linter.language.lower()
        linter_name_lower = linter.linter_name.lower().replace('-', '_')
        test_class_code = f"""# !/usr/bin/env python3
\"\"\"
Unit tests for {linter.language} linter {linter.linter_name}
This class has been automatically generated by .automation/build.py, please do not update it manually
\"\"\"
from superlinter.tests.test_superlinter.LinterTestRoot import LinterTestRoot


class {lang_lower}_{linter_name_lower}_test(LinterTestRoot):
    language = '{linter.language}'
    linter_name = '{linter.linter_name}'
"""
        file = open(
            f"{REPO_HOME}/superlinter/tests/test_superlinter/linters/{lang_lower}_{linter_name_lower}_test.py",
            'w')
        file.write(test_class_code)
        file.close()
        logging.info('Updated ' + file.name)


# Automatically generate README linters table and a MD file for each linter
def generate_linter_documentation():
    descriptor_files = superlinter.utils.list_descriptor_files()
    linters_by_type = {'language': [], 'format': [], 'tooling_format': []}
    for descriptor_file in descriptor_files:
        descriptor_linters = superlinter.utils.build_descriptor_linters(descriptor_file)
        linters_by_type[descriptor_linters[0].type] += descriptor_linters
    linters_tables_md = []
    process_type(linters_by_type, 'language', 'Languages', linters_tables_md)
    process_type(linters_by_type, 'format', 'Formats', linters_tables_md)
    process_type(linters_by_type, 'tooling_format', 'Tooling formats', linters_tables_md)
    linters_tables_md_str = "\n".join(linters_tables_md) + "\n"
    logging.info("Generated Linters table for README:\n" + linters_tables_md_str)
    replace_in_file(f"{REPO_HOME}/README.md", "<!-- linters-table-start -->",
                    "<!-- linters-table-end -->", linters_tables_md_str)


# Build a MD table for a type of linter (language, format, tooling_format )SSS
def process_type(linters_by_type, type1, type_label, linters_tables_md):
    linters_tables_md += [
        f"### {type_label}",
        "",
        "| Language / Format | Linter | Configuration key |",
        "| ----------------- | -------------- | ------------ |"]
    descriptor_linters = linters_by_type[type1]
    prev_lang = ''
    for linter in descriptor_linters:
        lang_lower = linter.language.lower()
        linter_name_lower = linter.linter_name.lower().replace('-', '_')
        # Append in general linter tables
        language_cell = f"**{linter.language}**" if prev_lang != linter.language else ''
        prev_lang = linter.language
        linter_doc_url = f"{DOCS_URL_DESCRIPTORS_ROOT}/{lang_lower}_{linter_name_lower}.md"
        linters_tables_md += [
            f"| {language_cell} | [{linter.linter_name}]({linter_doc_url})"
            f"| [{linter.name}]({linter_doc_url}) |"]
        # Build individual linter doc
        linter_doc_md = [
            "<!-- markdownlint-disable MD033 MD041 -->",
            "<!-- Generated by .automation/build.py, please do not update manually -->"
        ]
        # Header image as title
        if hasattr(linter, 'linter_header_image_url') and linter.linter_header_image_url is not None:
            linter_doc_md += [
                image_link(linter.linter_header_image_url, linter.linter_name,
                           linter.linter_url, "Visit linter Web Site", "center", 150)
            ]
        # Text + image as title
        elif hasattr(linter, 'linter_image_url') and linter.linter_image_url is not None:
            linter_doc_md += [
                "# " + logo_link(linter.linter_image_url, linter.linter_name,
                                 linter.linter_url, "Visit linter Web Site", 100) + linter.linter_name
            ]
        # Text as title
        else:
            linter_doc_md += [f"# {linter.linter_name}"]

        linter_doc_md += [
            "## Linted files",
            ""]
        if len(linter.file_extensions) > 0:
            linter_doc_md += ['- File extensions:']
        for file_extension in linter.file_extensions:
            linter_doc_md += [f"  - `{file_extension}`"]
        if len(linter.file_names) > 0:
            linter_doc_md += ['- File names:']
        for file_name in linter.file_names:
            linter_doc_md += [f"  - `{file_name}`"]
        if len(linter.file_contains) > 0:
            linter_doc_md += ['- Detected file content:']
        for file_contains_expr in linter.file_contains:
            linter_doc_md += [f"  - `{file_contains_expr}`"]

        linter_doc_md += [
            "## Configuration",
            "",
            "| Variable | Description | Default value |",
            "| ----------------- | -------------- | -------------- |",
            f"| VALIDATE_{linter.name} | Activate or deactivate {linter.linter_name} | `true` |",
            f"| {linter.name}_FILTER_REGEX_INCLUDE | Custom regex including filter |  |",
            f"| {linter.name}_FILTER_REGEX_EXCLUDE | Custom regex excluding filter |  |"
        ]
        if linter.config_file_name is not None:
            linter_doc_md += [
                f"| {linter.name}_FILE_NAME | Rules file name | `{linter.config_file_name}` |",
                f"| {linter.name}_RULES_PATH | Path where to find rules | "
                "Workspace folder, then super-linter default rules |"
            ]
        if linter.files_sub_directory is not None:
            linter_doc_md += [
                f"| {linter.language}_DIRECTORY | Directory containing {linter.language} files "
                f"| `{linter.files_sub_directory}` |"
            ]
        linter_doc_md += [
            "",
            "## Behind the scenes",
            "",
            "### Example calls",
            ""
        ]
        for example in linter.examples:
            linter_doc_md += [
                "```shell",
                example,
                "```",
                ""]

        linter_doc_md += [
            "### Linter web site",
            f"- [{linter.linter_url}]({linter.linter_url})",
            ""]

        file = open(f"{REPO_HOME}/docs/descriptors/{lang_lower}_{linter_name_lower}.md", 'w')
        file.write("\n".join(linter_doc_md) + "\n")
        file.close()
        logging.info('Updated ' + file.name)
    linters_tables_md += [""]
    return linters_tables_md


def image_link(src, alt, link, title, align, maxheight):
    return f"""
<div align=\"{align}\">
  <a href=\"{link}\" target=\"blank\" title=\"{title}\">
    <img src=\"{src}\" alt=\"{alt}\" height=\"{maxheight}px\">
  </a>
</div>
"""


def logo_link(src, alt, link, title, maxheight):
    return f"<a href=\"{link}\" target=\"blank\" title=\"{title}\">" \
           f"<img src=\"{src}\" alt=\"{alt}\" height=\"{maxheight}px\"></a>"


def replace_in_file(file_path, start, end, content):
    # Read in the file
    with open(file_path, 'r') as file:
        file_content = file.read()
    # Replace the target string
    replacement = f"{start}\n{content}\n{end}"
    regex = rf"{start}([\s\S]*?){end}"
    file_content = re.sub(regex, replacement, file_content, re.DOTALL)
    # Write the file out again
    with open(file_path, 'w') as file:
        file.write(file_content)
    logging.info('Updated ' + file.name)


if __name__ == '__main__':
    logging.basicConfig(force=True,
                        level=logging.INFO,
                        format='%(asctime)s [%(levelname)s] %(message)s',
                        handlers=[
                            logging.StreamHandler(sys.stdout)
                        ])
    # noinspection PyTypeChecker
    generate_dockerfile()
    generate_linter_test_classes()
    generate_linter_documentation()
